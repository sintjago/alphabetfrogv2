<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Alphabet Frog</title>
  <style>
    :root{
      --w: 600px;
      --panel: #ccc;
      --ink: #111;
      --muted: #444;
      --btn: #fff;
      --btnHover: #eee;
      --road: #2f2f2f;
      --safe: #d3d3d3;
      --river: #3498db;
      --frog: #006400;
      --good: #27ae60;
      --bad: #c0392b;
      --gold: #f1c40f;
      --shadow: rgba(0,0,0,0.20);
    }

    *{ box-sizing:border-box; }

    body{
      font-family: Arial, sans-serif;
      background-color: white;
      color: black;
      margin: 0;
      padding: 0;
    }

    /* Keep your "canonical" 600px design, but scale it down on small screens */
    .stage{
      display:flex;
      justify-content:center;
      padding: 10px 0 18px;
    }

    .game-wrapper{
      width: var(--w);
      transform-origin: top center;
    }

    @media (max-width: 640px){
      .game-wrapper{
        transform: scale(calc((100vw - 16px) / 600));
      }
    }

    h1.title{
      margin: 10px 0 6px;
      font-size: 28px;
      text-align: center;
      color: black;
      letter-spacing: 0.5px;
    }

    #header{
      width: var(--w);
      display:flex;
      justify-content:space-between;
      align-items:center;
      background-color: var(--panel);
      padding: 6px;
      gap: 6px;
      border-radius: 8px;
      box-shadow: 0 8px 18px var(--shadow);
    }

    #wordArea{
      display:flex;
      flex-direction:column;
      gap: 4px;
      min-width: 220px;
    }

    #wordDisplay{
      font-size: 24px;
      font-weight: bold;
      letter-spacing: 8px;
      cursor: pointer;
      display:flex;
      flex-wrap: nowrap;
      white-space: nowrap;
      user-select:none;
    }

    #wordDisplay span{
      padding: 4px 2px 3px;
      border-bottom: 2px solid white;
      transition: transform 120ms ease;
    }

    #wordDisplay span:active{
      transform: scale(0.96);
    }

    .collected{
      color: lime;
      border-bottom: 2px solid lime;
    }

    .nextLetter{
      border-bottom: 2px solid var(--gold) !important;
    }

    #statusLine{
      font-size: 13px;
      color: #222;
      padding: 2px 6px;
      background: rgba(255,255,255,0.7);
      border-radius: 6px;
      display:inline-flex;
      align-items:center;
      gap: 6px;
      width: fit-content;
    }

    #statusDot{
      width: 8px; height: 8px;
      border-radius: 50%;
      background: var(--gold);
      box-shadow: 0 0 0 2px rgba(0,0,0,0.06);
    }

    #controlsWrapper{
      display:flex;
      gap: 6px;
      flex-wrap: wrap;
      align-items: center;
      justify-content:flex-end;
    }

    button{
      background-color: var(--btn);
      color: #333;
      border: none;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 14px;
      cursor: pointer;
      box-shadow: 0 2px 0 rgba(0,0,0,0.08);
    }

    button:hover{ background-color: var(--btnHover); }
    button:active{ transform: translateY(1px); box-shadow:none; }

    .toggleBtn[aria-pressed="true"]{
      outline: 2px solid rgba(0,0,0,0.12);
    }

    #customWordInput, #csvInput{
      width: 140px;
      padding: 4px 8px;
      font-size: 14px;
      border-radius: 6px;
      border: 1px solid #888;
      background: white;
    }

    canvas{
      display:block;
      background-color: var(--safe);
      border: 2px solid #fff;
      margin: 10px auto 0;
      border-radius: 10px;
      box-shadow: 0 10px 22px var(--shadow);
    }

    .bottom-bar{
      display:flex;
      justify-content:space-between;
      align-items:center;
      width: var(--w);
      margin: 10px auto 0;
      font-size: 14px;
      gap: 10px;
    }

    #scoreBox{
      font-weight:bold;
      padding: 6px 10px;
      background: rgba(240,240,240,0.95);
      border-radius: 8px;
      display:flex;
      align-items:center;
      gap: 10px;
      box-shadow: 0 6px 14px rgba(0,0,0,0.10);
    }

    .meta{
      display:flex;
      gap: 10px;
      align-items:center;
    }

    .pill{
      background: rgba(255,255,255,0.9);
      border: 1px solid rgba(0,0,0,0.10);
      border-radius: 999px;
      padding: 4px 10px;
      font-weight: bold;
      color: #222;
    }

    .livesPips{
      display:flex;
      align-items:center;
      gap: 4px;
    }

    .pip{
      width: 10px; height: 10px;
      border-radius: 50%;
      background: white;
      border: 1px solid rgba(0,0,0,0.25);
    }

    .pip.on{
      background: #e74c3c;
      border-color: rgba(0,0,0,0.25);
    }

    .csv-section{
      display:flex;
      align-items:center;
      gap: 6px;
      flex-wrap: wrap;
      justify-content:flex-end;
    }

    #instructions{
      max-width: var(--w);
      margin: 12px auto 0;
      font-size: 14px;
      text-align: center;
      color: var(--muted);
    }

    /* Modal overlay (replaces alerts, keeps flow and audio happier) */
    #overlay{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.45);
      display:none;
      align-items:center;
      justify-content:center;
      z-index: 50;
      padding: 18px;
    }

    #overlay.show{ display:flex; }

    .modal{
      width: min(520px, 92vw);
      background: white;
      border-radius: 16px;
      box-shadow: 0 18px 50px rgba(0,0,0,0.35);
      padding: 16px 16px 12px;
    }

    .modal h2{
      margin: 0 0 8px;
      font-size: 20px;
      color: #111;
    }

    .modal p{
      margin: 0 0 12px;
      color: #333;
      line-height: 1.35;
    }

    .modal .row{
      display:flex;
      gap: 8px;
      justify-content:flex-end;
      flex-wrap: wrap;
    }

    .small{
      font-size: 12px;
      color: #666;
    }
  </style>
</head>

<body>
  <div class="stage">
    <div class="game-wrapper">
      <h1 class="title">Alphabet Frog</h1>

      <div id="header">
        <div id="wordArea">
          <div id="wordDisplay" title="Click to hear the word"></div>
          <div id="statusLine" aria-live="polite">
            <span id="statusDot"></span>
            <span id="statusText">Collect letters in order.</span>
          </div>
        </div>

        <div id="controlsWrapper">
          <button id="nextBtn">Next</button>
          <input id="customWordInput" type="text" placeholder="Enter word" />
          <button id="submitBtn">Submit</button>
          <button id="newGameBtn">New Game</button>
          <button id="smoothBtn" class="toggleBtn" aria-pressed="false" title="Smooth movement (optional)">Smooth: Off</button>
          <button id="pauseBtn" class="toggleBtn" aria-pressed="false" title="Pause">Pause</button>
        </div>
      </div>

      <canvas id="gameCanvas" width="600" height="520"></canvas>

      <div class="bottom-bar">
        <div id="scoreBox">
          <div class="meta">
            <span class="pill" id="scorePill">Score: 0</span>
            <span class="pill" id="wordsPill">Words: 0/5</span>
            <span class="pill" id="nextPill">Next: -</span>
          </div>

          <div class="livesPips" title="Lives" aria-label="Lives" id="livesPips"></div>

          <button id="toggleSoundBtn" class="toggleBtn" aria-pressed="true">üîä On</button>
        </div>

        <div class="csv-section">
          <label for="csvInput">Submit custom word list:</label>
          <input id="csvInput" type="text" placeholder="e.g. cat,dog,bird" />
          <button id="csvSubmitBtn">Submit</button>
        </div>
      </div>

      <div id="instructions">
        Complete <strong>5 words</strong> and then <strong>cross the road</strong> to win!
      </div>
    </div>
  </div>

  <!-- Modal Overlay -->
  <div id="overlay" role="dialog" aria-modal="true" aria-label="Game message">
    <div class="modal">
      <h2 id="overlayTitle">Message</h2>
      <p id="overlayBody">...</p>
      <div class="row">
        <button id="overlayNextBtn">Next Word</button>
        <button id="overlayNewBtn">New Game</button>
        <button id="overlayCloseBtn">Close</button>
      </div>
      <p class="small" id="overlayHint">Tip: Click letters in the word to hear them.</p>
    </div>
  </div>

<script>
/* -----------------------------
   Canvas + Core State
------------------------------ */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const frogSize = 20;
const frogStep = 20;

let frog = {
  x: canvas.width / 2 - frogSize / 2,
  y: canvas.height - frogSize,
  tx: canvas.width / 2 - frogSize / 2, // target position (for smooth mode)
  ty: canvas.height - frogSize,
  smooth: false
};

let paused = false;
let gameOver = false;
let gameWin = false;

let lives = 1;
let wordsCompleted = 0;
let score = 0;

let soundOn = true;

/* -----------------------------
   Layout + Lanes
------------------------------ */
const laneHeight = 40;
const safeZones = [
  { y: 0, h: laneHeight },                                   // top safe
  { y: canvas.height - laneHeight, h: laneHeight }           // bottom safe
];

const rivers = [160, 320]; // river bands (y positions)
const lanesY = [40, 80, 120, 200, 240, 280, 360, 400, 440];  // road bands

/* Bridges */
const bridgeWidth = frogSize * 2;
let riverBridges = []; // array per river: [x1, x2, ...]

// prettier bridges
function generateBridges(){
  riverBridges = rivers.map(() => {
    const count = Math.floor(Math.random() * 3) + 1; // 1..3
    const bridges = [];
    const minDist = bridgeWidth + 12;
    for (let i = 0; i < count; i++){
      let tries = 0;
      let bx;
      do{
        bx = Math.random() * (canvas.width - bridgeWidth);
        tries++;
      } while (bridges.some(x => Math.abs(x - bx) < minDist) && tries < 50);
      bridges.push(bx);
    }
    return bridges;
  });
}

/* -----------------------------
   Vehicles
------------------------------ */
const vehicles = [];
const vehicleWidth = 30;
const vehicleHeight = 20;

// baseline "speeds" converted to pixels/second
const carSpeedUnits = [1, 2, 3];
const carColors = ['#e74c3c','#3498db','#f1c40f','#2ecc71','#9b59b6','#e67e22','#1abc9c','#34495e'];

// Lane directions: alternating +1 / -1
const laneDirByY = {};
lanesY.forEach((y, i) => {
  laneDirByY[y] = (i % 2 === 0) ? 1 : -1;
});

// Difficulty ramp config
function speedMultiplier(){
  // gentle ramp: after each word, +4% speed, capped
  return Math.min(1 + wordsCompleted * 0.04, 1.25);
}

// bonus chance slightly decreases as difficulty rises (still present)
function bonusChance(){
  const base = 0.02; // 2%
  return Math.max(base - wordsCompleted * 0.002, 0.008);
}

/* -----------------------------
   Word Bank + Learning
------------------------------ */
const baseAlphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
let wordBank = ["DOG","CAT","MOON","FISH","BIRD","LION","TREE","BOOK","LOVE","QUIZ"];

let targetWord = "";
let currentLetterIndex = 0;

/* -----------------------------
   Speech (queued, cancellable)
------------------------------ */
const synth = window.speechSynthesis;
let speakChain = Promise.resolve();

function cancelSpeech(){
  try{
    speakChain = Promise.resolve();
    if (synth.speaking) synth.cancel();
  }catch(e){}
}

function speakQueued(text){
  if (!soundOn) return Promise.resolve();
  // chain to avoid speech collisions, maintain order
  speakChain = speakChain.then(() => new Promise(resolve => {
    if (!soundOn) return resolve();
    try{
      if (synth.speaking) synth.cancel();
      const utter = new SpeechSynthesisUtterance(text);
      utter.lang = "en-US";
      utter.onend = () => resolve();
      utter.onerror = () => resolve();
      utter.oncancel = () => resolve();
      synth.speak(utter);
    }catch(e){
      resolve();
    }
  }));
  return speakChain;
}

// Optional phonics cue (tiny, but can help)
function phonicsCue(letter){
  // Very light-touch: only some consonants get a helpful hint.
  const map = { C:"kuh", G:"guh", J:"jay", Q:"kyoo", X:"eks" };
  return map[letter] ? `${letter}. ${map[letter]}.` : `${letter}.`;
}

/* -----------------------------
   UI Helpers
------------------------------ */
const elWordDisplay = document.getElementById('wordDisplay');
const elStatusText = document.getElementById('statusText');
const elStatusDot = document.getElementById('statusDot');

const elScorePill = document.getElementById('scorePill');
const elWordsPill = document.getElementById('wordsPill');
const elNextPill  = document.getElementById('nextPill');

const elLivesPips = document.getElementById('livesPips');

function setStatus(text, tone="gold"){
  elStatusText.textContent = text;
  const color = (tone==="good") ? "var(--good)" : (tone==="bad") ? "var(--bad)" : "var(--gold)";
  elStatusDot.style.background = color;
}

function sanitizeWord(w){
  return (w || "")
    .toUpperCase()
    .replace(/[^A-Z]/g, "");
}

function sanitizeCSV(csv){
  return (csv || "")
    .split(',')
    .map(x => sanitizeWord(x.trim()))
    .filter(x => x.length > 0);
}

function updateHUD(){
  elScorePill.textContent = `Score: ${score}`;
  elWordsPill.textContent = `Words: ${Math.min(wordsCompleted,5)}/5`;
  const nextLetter = targetWord[currentLetterIndex] || "-";
  elNextPill.textContent = `Next: ${nextLetter}`;
  renderLivesPips();
}

function renderLivesPips(){
  // show up to 8 pips for visibility, still supports more lives
  const show = Math.min(lives, 8);
  elLivesPips.innerHTML = "";
  for (let i = 0; i < show; i++){
    const d = document.createElement('div');
    d.className = "pip on";
    elLivesPips.appendChild(d);
  }
  for (let i = show; i < Math.min(8, Math.max(3, lives)); i++){
    const d = document.createElement('div');
    d.className = "pip";
    elLivesPips.appendChild(d);
  }
  if (lives > 8){
    const extra = document.createElement('span');
    extra.style.fontWeight = "bold";
    extra.style.marginLeft = "6px";
    extra.textContent = `+${lives - 8}`;
    elLivesPips.appendChild(extra);
  }
}

function updateWordDisplay(){
  elWordDisplay.innerHTML = "";
  for (let i = 0; i < targetWord.length; i++){
    const span = document.createElement('span');
    span.textContent = targetWord[i];

    if (i < currentLetterIndex) span.classList.add('collected');
    if (i === currentLetterIndex) span.classList.add('nextLetter');

    // Click any letter to hear it (learning boost)
    span.addEventListener('click', (e) => {
      e.stopPropagation();
      const L = targetWord[i];
      speakQueued(phonicsCue(L));
    });

    elWordDisplay.appendChild(span);
  }
}

/* -----------------------------
   Modal Overlay
------------------------------ */
const overlay = document.getElementById('overlay');
const overlayTitle = document.getElementById('overlayTitle');
const overlayBody = document.getElementById('overlayBody');

const overlayNextBtn = document.getElementById('overlayNextBtn');
const overlayNewBtn  = document.getElementById('overlayNewBtn');
const overlayCloseBtn= document.getElementById('overlayCloseBtn');

function showOverlay(title, body){
  overlayTitle.textContent = title;
  overlayBody.textContent = body;
  overlay.classList.add('show');
}

function hideOverlay(){
  overlay.classList.remove('show');
}

overlayCloseBtn.addEventListener('click', () => {
  hideOverlay();
});

overlayNewBtn.addEventListener('click', () => {
  hideOverlay();
  startNewGame(true);
});

overlayNextBtn.addEventListener('click', () => {
  hideOverlay();
  chooseRandomWord();
  resetVehiclesOnly();
  setStatus(`New word: ${targetWord}. Next letter: ${targetWord[0]}.`, "gold");
});

/* -----------------------------
   Word Selection
------------------------------ */
function chooseRandomWord(){
  targetWord = wordBank[Math.floor(Math.random() * wordBank.length)] || "CAT";
  targetWord = sanitizeWord(targetWord);
  if (!targetWord) targetWord = "CAT";
  currentLetterIndex = 0;
  updateWordDisplay();
  updateHUD();
}

function setCustomWord(word){
  const clean = sanitizeWord(word);
  if (!clean){
    setStatus("That word had no letters A‚ÄìZ. Try again.", "bad");
    return false;
  }
  targetWord = clean;
  currentLetterIndex = 0;
  updateWordDisplay();
  updateHUD();
  return true;
}

/* -----------------------------
   Vehicle Creation
------------------------------ */
function createVehiclesForLane(y){
  const alphabet = [...baseAlphabet];

  // bias toward letters in the current target word
  const extraLetters = targetWord.split('').flatMap(l => [l, l]); // double weight
  const allLetters = alphabet.concat(extraLetters);

  const used = new Set();
  const lettersThisLane = [];

  const numCars = 6;
  for (let i = 0; i < numCars; i++){
    let letter;
    let guard = 0;
    do{
      letter = allLetters[Math.floor(Math.random() * allLetters.length)];
      guard++;
    } while (used.has(`${y}-${letter}`) && guard < 200);
    used.add(`${y}-${letter}`);
    lettersThisLane.push(letter);
  }

  const minGap = 70;
  const dir = laneDirByY[y] || 1;

  lettersThisLane.forEach((letter, i) => {
    const isBonus = Math.random() < bonusChance(); // still present, tuned
    const unit = carSpeedUnits[Math.floor(Math.random() * carSpeedUnits.length)];
    const pxPerSecond = unit * 60; // baseline conversion

    // spawn offscreen based on direction
    let x;
    if (dir === 1){
      x = -canvas.width - i * (vehicleWidth + minGap);
    }else{
      x = canvas.width + canvas.width + i * (vehicleWidth + minGap);
    }

    vehicles.push({
      x,
      y,
      w: vehicleWidth,
      h: vehicleHeight,
      dir,
      baseSpeed: pxPerSecond,
      speed: pxPerSecond,
      color: isBonus ? '#ff69b4' : carColors[Math.floor(Math.random() * carColors.length)],
      letter: isBonus ? '1+' : letter,
      bonus: isBonus,
      pulse: Math.random() * Math.PI * 2
    });
  });
}

function fullReset(){
  vehicles.length = 0;
  generateBridges();

  frog.x = canvas.width / 2 - frogSize / 2;
  frog.y = canvas.height - frogSize;
  frog.tx = frog.x;
  frog.ty = frog.y;

  gameOver = false;
  gameWin = false;

  lanesY.forEach(laneY => createVehiclesForLane(laneY));
}

function resetVehiclesOnly(){
  vehicles.length = 0;
  generateBridges();
  gameOver = false;
  gameWin = false;
  lanesY.forEach(laneY => createVehiclesForLane(laneY));
}

/* -----------------------------
   Drawing
------------------------------ */
function drawBackground(){
  // safe zones
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--safe').trim();
  ctx.fillRect(0, 0, canvas.width, laneHeight);
  ctx.fillRect(0, canvas.height - laneHeight, canvas.width, laneHeight);

  // rivers + bridges
  rivers.forEach((riverY, idx) => {
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--river').trim();
    ctx.fillRect(0, riverY, canvas.width, laneHeight);

    const bridges = riverBridges[idx] || [];
    bridges.forEach(bridgeX => {
      // planks
      const plankW = 5;
      for (let i = 0; i < bridgeWidth; i += plankW){
        ctx.fillStyle = (i % (plankW*2) === 0) ? '#f5deb3' : '#deb887';
        ctx.fillRect(bridgeX + i, riverY, plankW, laneHeight);
      }
      // rails
      ctx.fillStyle = 'rgba(0,0,0,0.15)';
      ctx.fillRect(bridgeX, riverY + 2, bridgeWidth, 2);
      ctx.fillRect(bridgeX, riverY + laneHeight - 4, bridgeWidth, 2);
    });
  });

  // roads
  lanesY.forEach(y => {
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--road').trim();
    ctx.fillRect(0, y, canvas.width, laneHeight);

    // faint lane stripes for style
    ctx.fillStyle = 'rgba(255,255,255,0.08)';
    for (let i = 0; i < canvas.width; i += 36){
      ctx.fillRect(i, y + laneHeight/2 - 1, 18, 2);
    }
  });
}

function drawFrog(){
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--frog').trim();
  ctx.fillRect(frog.x, frog.y, frogSize, frogSize);

  // tiny eyes (because why not üê∏)
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  ctx.fillRect(frog.x + 4, frog.y + 4, 3, 3);
  ctx.fillRect(frog.x + frogSize - 7, frog.y + 4, 3, 3);
}

function drawVehicles(dt){
  // group by lane for spacing logic
  const lanesMap = {};
  for (let car of vehicles){
    if (!lanesMap[car.y]) lanesMap[car.y] = [];
    lanesMap[car.y].push(car);
  }

  // Update + draw per lane
  for (let y in lanesMap){
    const cars = lanesMap[y];
    const dir = cars[0]?.dir || 1;

    // Update speed: ensure "rear car slows behind front car"
    // We'll compute nearest ahead car per vehicle using cyclic distance.
    for (let i = 0; i < cars.length; i++){
      const car = cars[i];
      car.speed = car.baseSpeed * speedMultiplier();

      // find nearest car ahead along direction
      let best = null;
      let bestDist = Infinity;

      for (let j = 0; j < cars.length; j++){
        if (i === j) continue;
        const other = cars[j];

        let dist;
        if (dir === 1){
          // ahead = larger x, wrap with +canvas.width*2 range
          dist = (other.x - car.x);
          if (dist <= 0) dist += (canvas.width + canvas.width); // wrap
        }else{
          // moving left, ahead = smaller x
          dist = (car.x - other.x);
          if (dist <= 0) dist += (canvas.width + canvas.width);
        }

        if (dist < bestDist){
          bestDist = dist;
          best = other;
        }
      }

      const desiredGap = car.w + 14;
      if (best && bestDist < desiredGap){
        // slow the rear car to not exceed front car
        car.speed = Math.min(car.speed, best.speed);
      }
    }

    // Move cars
    for (let i = 0; i < cars.length; i++){
      const car = cars[i];

      car.x += (car.dir === 1 ? 1 : -1) * car.speed * dt;

      // wrap / respawn offscreen nicely
      if (car.dir === 1 && car.x > canvas.width + 70){
        car.x = -vehicleWidth - Math.random() * 80;
        car.baseSpeed = carSpeedUnits[Math.floor(Math.random() * carSpeedUnits.length)] * 60;
      } else if (car.dir === -1 && car.x < -vehicleWidth - 70){
        car.x = canvas.width + vehicleWidth + Math.random() * 80;
        car.baseSpeed = carSpeedUnits[Math.floor(Math.random() * carSpeedUnits.length)] * 60;
      }

      // draw car
      if (car.bonus){
        car.pulse += dt * 6;
        const glow = 0.35 + 0.25 * Math.sin(car.pulse);
        ctx.save();
        ctx.shadowColor = `rgba(255,105,180,${glow})`;
        ctx.shadowBlur = 12;
        ctx.fillStyle = car.color;
        ctx.fillRect(car.x, car.y, car.w, car.h);
        ctx.restore();
      }else{
        ctx.fillStyle = car.color;
        ctx.fillRect(car.x, car.y, car.w, car.h);
      }

      ctx.fillStyle = 'white';
      ctx.font = '14px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(car.letter, car.x + car.w/2, car.y + car.h/2);
    }
  }
}

/* -----------------------------
   Collisions (AABB)
------------------------------ */
function rectsOverlap(a, b){
  return (
    a.x < b.x + b.w &&
    a.x + a.w > b.x &&
    a.y < b.y + b.h &&
    a.y + a.h > b.y
  );
}

function frogRect(){
  return { x: frog.x, y: frog.y, w: frogSize, h: frogSize };
}

function handleCarCollisions(){
  const fr = frogRect();

  // Only check road lanes
  for (let i = vehicles.length - 1; i >= 0; i--){
    const car = vehicles[i];
    const roadBand = lanesY.includes(car.y);
    if (!roadBand) continue;

    const cr = { x: car.x, y: car.y + (laneHeight - car.h)/2, w: car.w, h: car.h };

    if (!rectsOverlap(fr, cr)) continue;

    if (car.bonus){
      lives++;
      updateHUD();
      setStatus("Bonus! +1 life.", "good");
      vehicles.splice(i, 1);
      speakQueued("Extra life!");
      continue;
    }

    const expected = targetWord[currentLetterIndex];

    if (car.letter === expected){
      // correct letter
      const got = car.letter;
      vehicles.splice(i, 1);

      currentLetterIndex++;
      updateWordDisplay();
      updateHUD();

      setStatus(`Nice! Collected ${got}. Next: ${targetWord[currentLetterIndex] || "done!"}`, "good");
      speakQueued(phonicsCue(got));

      // word completed?
      if (currentLetterIndex >= targetWord.length){
        wordsCompleted++;
        score++; // keep your existing scoring behavior (+1 per completed word)
        updateHUD();

        setStatus(`Word complete: ${targetWord}. New word incoming‚Ä¶`, "good");

        // speak full word after letter audio finishes
        speakQueued(targetWord).then(() => {
          // choose new word after speech to keep it clean
          chooseRandomWord();
          resetVehiclesOnly();
          setStatus(`New word: ${targetWord}. Next letter: ${targetWord[0]}.`, "gold");
        });
      }
    }else{
      // wrong letter
      lives--;
      updateHUD();
      setStatus(`Oops. Needed ${expected}, got ${car.letter}.`, "bad");
      speakQueued(`No. Needed ${expected}.`);

      if (lives <= 0){
        triggerGameOver();
      }else{
        respawnFrog();
      }
      return; // one collision per frame is enough
    }
  }
}

/* -----------------------------
   Rivers (with smooth movement)
------------------------------ */
function frogInRiverBand(){
  // Check if frog overlaps a river band (not just exact y match)
  const fr = frogRect();
  for (let i = 0; i < rivers.length; i++){
    const ry = rivers[i];
    const band = { x: 0, y: ry, w: canvas.width, h: laneHeight };
    if (rectsOverlap(fr, band)){
      return i;
    }
  }
  return -1;
}

function frogOnBridge(riverIndex){
  const bridges = riverBridges[riverIndex] || [];
  const fr = frogRect();
  const ry = rivers[riverIndex];
  // on bridge if any overlap with bridge rectangle
  return bridges.some(bx => rectsOverlap(fr, { x: bx, y: ry, w: bridgeWidth, h: laneHeight }));
}

function handleRiverHazard(){
  const idx = frogInRiverBand();
  if (idx === -1) return;

  if (!frogOnBridge(idx)){
    lives--;
    updateHUD();
    setStatus("Splash! You missed the bridge.", "bad");
    speakQueued("Splash!");
    if (lives <= 0){
      triggerGameOver();
    }else{
      respawnFrog();
    }
  }
}

/* -----------------------------
   Win Condition
------------------------------ */
function checkWin(){
  if (frog.y <= 0 && wordsCompleted >= 5){
    gameWin = true;
    paused = true;
    cancelSpeech();
    setStatus("You win!", "good");
    speakQueued("You win!");
    spawnConfetti();
    showOverlay("You Win! üê∏üèÅ", `You completed 5 words and crossed the road. Score: ${score}.`);
  }
}

/* -----------------------------
   Game Over / Respawn / Reset
------------------------------ */
function respawnFrog(){
  frog.x = canvas.width / 2 - frogSize / 2;
  frog.y = canvas.height - frogSize;
  frog.tx = frog.x;
  frog.ty = frog.y;
}

function triggerGameOver(){
  gameOver = true;
  paused = true;
  cancelSpeech();
  speakQueued("Game over.");
  showOverlay("Game Over", `You ran out of lives. Score: ${score}. Words: ${Math.min(wordsCompleted,5)}/5.`);
}

function startNewGame(hard=false){
  // hard = full restart of stats
  hideOverlay();
  cancelSpeech();

  if (hard){
    score = 0;
    lives = 1;
    wordsCompleted = 0;
  }

  paused = false;
  gameOver = false;
  gameWin = false;

  chooseRandomWord();
  fullReset();

  setStatus(`New game. Next letter: ${targetWord[0]}.`, "gold");
}

/* -----------------------------
   Confetti (win flair)
------------------------------ */
let confetti = [];

function spawnConfetti(){
  confetti = [];
  for (let i = 0; i < 90; i++){
    confetti.push({
      x: canvas.width/2,
      y: 20,
      vx: (Math.random() - 0.5) * 320,
      vy: 80 + Math.random() * 260,
      g: 420 + Math.random() * 240,
      r: 2 + Math.random() * 3,
      life: 1.2 + Math.random() * 0.8
    });
  }
}

function updateConfetti(dt){
  if (!confetti.length) return;
  for (let i = confetti.length - 1; i >= 0; i--){
    const p = confetti[i];
    p.life -= dt;
    p.vy += p.g * dt;
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    if (p.life <= 0) confetti.splice(i, 1);
  }

  // draw on top
  ctx.save();
  for (const p of confetti){
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.restore();
}

/* -----------------------------
   Input (prevent scroll + smooth mode)
------------------------------ */
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

function moveFrogBy(dx, dy){
  if (gameOver || gameWin) return;
  if (paused) return;

  const nx = clamp(frog.tx + dx, 0, canvas.width - frogSize);
  const ny = clamp(frog.ty + dy, 0, canvas.height - frogSize);

  frog.tx = nx;
  frog.ty = ny;

  if (!frog.smooth){
    frog.x = frog.tx;
    frog.y = frog.ty;
    // immediate hazards for grid mode
    handleRiverHazard();
    checkWin();
  }
}

function onKeyDown(e){
  const keys = ["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"];
  if (keys.includes(e.key)) e.preventDefault();

  if (e.key === "p" || e.key === "P"){
    togglePause();
    return;
  }

  if (paused || gameOver || gameWin) return;

  switch (e.key){
    case "ArrowUp":    moveFrogBy(0, -frogStep); break;
    case "ArrowDown":  moveFrogBy(0, frogStep); break;
    case "ArrowLeft":  moveFrogBy(-frogStep, 0); break;
    case "ArrowRight": moveFrogBy(frogStep, 0); break;
  }
}

window.addEventListener('keydown', onKeyDown, { passive: false });

/* -----------------------------
   Buttons + Controls
------------------------------ */
document.getElementById('wordDisplay').addEventListener('click', () => {
  speakQueued(targetWord);
});

document.getElementById('nextBtn').addEventListener('click', () => {
  if (paused && !gameOver && !gameWin) return;
  chooseRandomWord();
  resetVehiclesOnly();
  setStatus(`Next word: ${targetWord}. Next letter: ${targetWord[0]}.`, "gold");
});

document.getElementById('submitBtn').addEventListener('click', () => {
  const custom = document.getElementById('customWordInput').value.trim();
  if (custom.length > 0){
    if (setCustomWord(custom)){
      resetVehiclesOnly();
      setStatus(`Custom word set: ${targetWord}.`, "gold");
    }
  }
});

document.getElementById('csvSubmitBtn').addEventListener('click', () => {
  const csv = document.getElementById('csvInput').value.trim();
  if (csv.length > 0){
    const cleaned = sanitizeCSV(csv);
    if (!cleaned.length){
      setStatus("No valid words found in that CSV.", "bad");
      return;
    }
    wordBank = cleaned;
    chooseRandomWord();
    resetVehiclesOnly();
    setStatus(`Loaded ${wordBank.length} custom words. New word: ${targetWord}.`, "good");
  }
});

document.getElementById('newGameBtn').addEventListener('click', () => {
  startNewGame(true);
});

function togglePause(){
  paused = !paused;
  const btn = document.getElementById('pauseBtn');
  btn.setAttribute("aria-pressed", paused ? "true" : "false");
  btn.textContent = paused ? "Resume" : "Pause";
  if (paused){
    setStatus("Paused. Press Resume (or P) to continue.", "gold");
    cancelSpeech();
  }else{
    setStatus(`Back to it. Next letter: ${targetWord[currentLetterIndex] || "-"}.`, "gold");
  }
}

document.getElementById('pauseBtn').addEventListener('click', togglePause);

document.getElementById('smoothBtn').addEventListener('click', () => {
  frog.smooth = !frog.smooth;
  const btn = document.getElementById('smoothBtn');
  btn.setAttribute("aria-pressed", frog.smooth ? "true" : "false");
  btn.textContent = frog.smooth ? "Smooth: On" : "Smooth: Off";
  setStatus(frog.smooth ? "Smooth movement enabled." : "Grid movement enabled.", "gold");
});

document.getElementById('toggleSoundBtn').addEventListener('click', () => {
  soundOn = !soundOn;
  localStorage.setItem("alphabetFrog_soundOn", soundOn ? "1" : "0");

  const btn = document.getElementById('toggleSoundBtn');
  btn.textContent = soundOn ? "üîä On" : "üîá Off";
  btn.setAttribute("aria-pressed", soundOn ? "true" : "false");

  if (!soundOn) cancelSpeech();
});

/* Pause when tab hidden (prevents CPU + speech weirdness) */
document.addEventListener("visibilitychange", () => {
  if (document.hidden){
    paused = true;
    const btn = document.getElementById('pauseBtn');
    btn.setAttribute("aria-pressed", "true");
    btn.textContent = "Resume";
    cancelSpeech();
  }
});

/* Load saved sound state */
(function initSoundPref(){
  const saved = localStorage.getItem("alphabetFrog_soundOn");
  if (saved === "0"){
    soundOn = false;
    const btn = document.getElementById('toggleSoundBtn');
    btn.textContent = "üîá Off";
    btn.setAttribute("aria-pressed", "false");
  }
})();

/* -----------------------------
   Main Loop (delta-time)
------------------------------ */
let lastT = performance.now();

function step(now){
  const dt = Math.min((now - lastT) / 1000, 0.04); // cap dt to avoid jumps
  lastT = now;

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  drawBackground();

  // Smooth movement toward target
  if (!paused && frog.smooth && !gameOver && !gameWin){
    const ease = 22; // responsiveness
    frog.x += (frog.tx - frog.x) * Math.min(1, ease * dt);
    frog.y += (frog.ty - frog.y) * Math.min(1, ease * dt);

    // When close enough, snap and check hazards
    if (Math.abs(frog.tx - frog.x) < 0.4) frog.x = frog.tx;
    if (Math.abs(frog.ty - frog.y) < 0.4) frog.y = frog.ty;

    // Only check river hazard when frog is essentially on its target cell
    if (frog.x === frog.tx && frog.y === frog.ty){
      handleRiverHazard();
      checkWin();
    }
  }

  drawFrog();

  if (!paused && !gameOver && !gameWin){
    drawVehicles(dt);
    handleCarCollisions();
  }else{
    // still draw vehicles in pause? keep them frozen for clarity
    drawVehicles(0);
  }

  updateConfetti(dt);

  requestAnimationFrame(step);
}

/* -----------------------------
   Start Up
------------------------------ */
function init(){
  chooseRandomWord();
  fullReset();
  updateHUD();
  setStatus(`New word: ${targetWord}. Next letter: ${targetWord[0]}.`, "gold");
  requestAnimationFrame(step);
}

init();
</script>
</body>
</html>
